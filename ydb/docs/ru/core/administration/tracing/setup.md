# Настройка трассировки {{ ydb-short-name }}

Для настройки трейсинга добавьте в конфигурацию (`cluster.yaml`) следующую секцию:

```yaml
tracing_config:
  backend:
    opentelemetry:
      collector_url: grpc://collector.ru:4317
      service_name: ydb
  uploader:
    max_spans_per_second: 10
    max_spans_burst: 25
    span_ttl_seconds: 60
  external_throttling:
    - max_rate_per_minute: 60
      max_burst: 3
  sampling:
    - scope:
        request_type: KeyValue.ExecuteTransaction
      fraction: 0.001
      level: 15
      max_rate_per_minute: 5
      max_burst: 2
```

Секции `external_throttling` и `sampling` можно менять с помощью механизма [динамической конфигурации](../../maintenance/manual/dynamic-config.md), изменение остальных секций с помощью этого механизма пока недоступно.

## Описание секций

### Backend

В этой секции описывается коллектор спанов. На данный момент единственная опция – `opentelemetry`. Доставка спанов с узла кластера в коллектор происходит по push-модели, от коллектора требуется совместимость с [OTLP](https://opentelemetry.io/docs/specs/otlp/).

В секции `opentelemetry`:
* `collector_url` — URL коллектора спанов, схема может быть либо `grpc://` для небезопасного подключения, либо `grpcs://` для TLS-подключения
* `service_name` — имя сервиса, которым будут подписываться все спаны

Оба параметра являются обязательными

### Uploader {#uploader}

Uploader – компонент узла кластера, который занимается отправкой спанов в коллектор. Во избежание перегрузки коллектора спанов, uploader не будет отправлять больше, чем `max_spans_per_second` спанов в секунду в среднем. Максимально за раз он может отправить `max_burst` спанов. Сгенерированный спан попадает в очередь, из которой uploader берет спаны для отправки. Если спан лежит в очереди больше, чем `span_ttl_seconds`, он выбрасывается и, как следствие, не отправляется в коллектор.

Значения по умолчанию:
* `max_spans_per_second = 10`
* `max_spans_burst = 25`
* `span_ttl_seconds = 60`

Секция `uploader` может полностью отсутствовать, в таком случае для каждого параметра будет использоваться значение по умолчанию.

{% note info %}

Uploader – локальный для узла компонент, как следствие, описанные ограничения применяются к каждому узлу отдельно, а не ко всему кластеру вцелом.

{% endnote %}

### External throttling

Данная секция контроллирует, какое количество запросов, приходящих извне с собственными trace-id будут трассироваться системой. Способ передачи trace-id описан в [{#T}](./external-traces.md). Ограничения описываются последовательностью правил, каждое правило содержит:

* `scope` – набор селекторов для фильтрации запроса.
* `max_rate_per_minute` – наибольшее среднее количество запросов в минуту, пропускаемое по данному правилу.
* `max_burst` – максимальный всплеск количества трассируемых извне запросов

Обязательным параметром является только `max_rate_per_minute`.

### Sampling

Данная секция контролирует сэмплирование запросов в формате аналогичном `external_throttling`, каждое правило имеет два дополнительные поля:

* `fraction` – доля запросов, сэмплированных по данному правилу. Ожидается дробное число от 0 до 1.
* `level` — уровень сэмплирования (уровни компонент определены [здесь](https://github.com/ydb-platform/ydb/blob/7f54b7193ead3595490220034854718679991aaa/ydb/library/wilson_ids/wilson.h)), компоненты с уровнем выше обозначенного не будут присутствовать в трассе. Семантика `level` может быть изменена в будущем. Обязательный параметр, ожидается целое число от 0 до 15 включительно.

Оба поля являются обязательными.

## Семантика правил

### Селекторы

На данный момент поддерживаются селекторы:

* `request_type`
    
    Возможные значения:
    * KeyValue.AcquireLock
    * KeyValue.ExecuteTransaction
    * KeyValue.Read
    * KeyValue.ReadRange
    * KeyValue.ListRange
    * KeyValue.GetStorageChannelStatus

Запрос подходит под правило, если он подходит под все селекторы. `scope` может отсутствовать, это равносильно пустому набору селекторов, все запросы будут попадать под это правило.

### Rate limiting

Параметры `max_rate_per_minute` и `max_burst` используются для ограничения сверху на количество запросов. В случе sampling они ограничивают количество запросов, сэмплированных по данному правилу. В случае external throttling они ограничивают количество внешних трасс, которые попадают в систему.

Для ограничений используется вариация [leaky bucket](https://en.wikipedia.org/wiki/Leaky_bucket) с размером бакета равным `max_burst + 1`. Например, если `max_rate_per_minute = 60` и `max_burst = 0`, то при потоке в 1000 запросов в минуту будет трассироваться один запрос каждую секунду. Если же `max_burst = 20`, то при поступлении аналогичного потока запросов первые 21 будут оттрассированы, далее аналогично будет трассироваться один запрос в секунду.

### Правила

Семантика каждого правила такова: оно гарантирует квоту на количество запросов данной категории. Например, если секция `external_throttling` выглядит следующим образом:

```yaml
tracing_config:
  external_throttling:
    - max_rate_per_minute: 60
    - scope:
        request_type: KeyValue.ReadRange
      max_rate_per_minute: 20
```

При достаточном потоке запросов, будет трассироваться хотя бы 60 запросов в минуту извне и хотя бы 20 запросов в минуту типа `KeyValue.ReadRange`. Всего трассироваться будут не более 80 запросов в минуту.

Алгоритм решения следующий: для запроса, имеющего внешний trace-id, определяется набор правил, под которые подходит данный запрос. Запрос занимает место в квоте всех правил, в которых еще есть место. Если ни в одном правиле нет квоты, запрос не трассируется.

В случае сэмплирования семантика правила аналогична: гарантируется, что при достаточном потоке запросов данной категории, будет сэплироваться хотя бы `fraction` запросов с уровнем хотя бы `level`.

Алгоритм аналогичный аналогичный: для запроса, не имеющего внешнего trace-id (либо из-за его изначального отсутствия, либо из-за принятого ранее решения о не трассировании данного запроса), определяется набор правил, под которые подходит данный запрос. Запрос занимает место в квоте всех правил, в которых еще есть место и которые случайным образом "решили" его сэмплировать. Если ни по одному правилу запрос не нужно сэмлировать, он не сэмплируется, в противном случае уровень детализации определяется, как максимальный среди правил, которые "решили" его сэмплировать.

Например, при данной конфигурации `sampling`:

```yaml
tracing_config:
  sampling:
    - scope:
        request_type: KeyValue.ExecuteTransaction
      fraction: 0.5
      level: 5 
      max_rate_per_minute: 100
    - scope:
        request_type: KeyValue.ExecuteTransaction
      fraction: 0.01
      level: 15
      max_rate_per_minute: 5
```

При достаточно маленьном потоке запросов типа KeyValue.ExecuteTransaction, будут сэмплироваться:

* 1% запросов с уровнем детализации 15
* 49.5% запросов с уровнем детализации 5

При достаточно большом потоке запросов типа KeyValue.ExecuteTransaction, будут сэмплироваться:

* 5 запросов в минуту с уровнем детализации 15
* от 95 до 100 запросов в минуту с уровнем детализации 5

## Scope

### Селекторы
